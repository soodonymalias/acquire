<body>
<div id="gameDiv" style="display: flex;"></div>
<div id="prompt"></div>
<div>
<button type="button" onclick="start()">Start new game</button> with
<select id="count">
<option value="2">2</option>
<option value="3">3</option>
<option value="4" selected>4</option>
<option value="5">5</option>
<option value="6">6</option>
</select>
players and mode:
<select id="mode">
<option value="ai" selected>AI</option>
<option value="human">Play against yourself</option>
</select>
</div>
<script>
function start() {
  window.game = new Game(parseInt(count.value), mode.value == "ai");
}

function drawGrid(rows, cols, id) {
  let oldTable = document.getElementById(id);
  if (oldTable != null)
    oldTable.remove();

  let table = document.createElement("table");
  table.id = id;
  table.style.border = "3px solid black";
  gameDiv.appendChild(table);
  for (let i = 0; i < rows; i++) {
    let tr = table.insertRow();
    for (let j = 0; j < cols; j++) {
      let cell = tr.insertCell();
      cell.style.padding = "0px";
      cell.style.border = "1px solid black";
      cell.style.boxSizing = "border-box";
      cell.style.textAlign = "center";
      cell.style.touchAction = "manipulation";
    }
  }
}

function resizeGrid(grid) {
  let rows = grid.rows.length;
  let cols = grid.rows[0].cells.length;
  let cellDimension;
  if (window.visualViewport.height > window.visualViewport.width) {
    cellDimension = window.visualViewport.height * .4  / cols;
    gameDiv.style.flexDirection = "column";
  } else {
    cellDimension = window.visualViewport.width * .4 / rows;
    gameDiv.style.flexDirection = "row";
  }
  for (var i = 0; i < rows; i++) {
    for (var j = 0; j < cols; j++) {
      let cell = grid.rows[i].cells[j];
      cell.style.height = cellDimension;
      cell.style.width = cellDimension;
    }  
  }
}

function resize() {
  if (document.getElementById("uiBoard") == null)
    return;
  resizeGrid(uiBoard);
  resizeGrid(assets);
}
visualViewport.onresize = resize;
</script>
<script>
const neighbors = [[0,1], [1,0], [0,-1], [-1, 0]];
const rowsBeforePlayers = 3;
const names = ["You", "Alice", "Bob", "Charlie", "David", "Erin"]
class Game {
  constructor(playerCount, use_ai) {
    drawGrid(9, 12, "uiBoard");
    drawGrid(playerCount + 4, 9, "assets");
    resize();

    this.ai = use_ai;
    this.board = new Array(9);
    this.availableTiles = new Array();
    for (let i = 0; i < 9; i++) {
      this.board[i] = new Array(12);
      for (let j = 0; j < 12; j++) {
        this.updateBoard(i, j, "open");
        this.availableTiles.push({ i: i, j: j });
      }
    }

    this.chains = [
      { color: "red",     basePrice: 2, size: 0, sharesRemaining: 25 },
      { color: "yellow",  basePrice: 2, size: 0, sharesRemaining: 25 },
      { color: "green",   basePrice: 3, size: 0, sharesRemaining: 25 },
      { color: "blue",    basePrice: 3, size: 0, sharesRemaining: 25 },
      { color: "sienna",  basePrice: 3, size: 0, sharesRemaining: 25 },
      { color: "cyan",    basePrice: 4, size: 0, sharesRemaining: 25 },
      { color: "hotpink", basePrice: 4, size: 0, sharesRemaining: 25 },
    ];

    this.players = new Array(playerCount);
    for (let i = 0; i < this.players.length; i++) {
      this.players[i] = { tiles : new Set(), name: names[i], shares: new Array(this.chains.length).fill(0), cash: 60 }
    }

    this.playInitialTiles();
    this.initAssets();
    document.getElementById("prompt").innerText = "";
    this.gameLoop();
  }

  initAssets() {
    let rows = assets.rows.length;
    let cols = assets.rows[0].cells.length;
    for (var j = 1; j < cols - 1; j++) {
      let cell = assets.rows[0].cells[j];
      cell.style.backgroundColor = this.chains[j-1].color;
    }
    assets.rows[0].cells[cols-1].innerText = "Cash";
    assets.rows[1].cells[0].innerText = "Size";
    assets.rows[2].cells[0].innerText = "Price";

    for (let i = 0; i < this.players.length; i++) {
      let cell = assets.rows[i+rowsBeforePlayers].cells[0];
      cell.innerText = this.players[i].name;
    }
    assets.rows[rows-1].cells[0].innerText = "Shares remaining";
    this.updateAssets();
  }

  useAI(player) {
    return this.ai && player != 0;
  }

  getChainPrice(c) {
    return this.chains[c].basePrice + (() => {
      let size = this.chains[c].size;
      if (size < 5)
        return size - 2;
      if (size <= 10)
        return 4;
      if (size <= 20)
        return 5;
      if (size <= 30)
        return 6;
      if (size <= 40)
        return 7;
      return 8;
    })();
  }

  updateAssets() {
    for (let p = 0; p < this.players.length; p++) {
      assets.rows[p+rowsBeforePlayers].cells[0].style.border = (p == this.currentPlayer) ? "5px solid" : "1px solid";

      for (let c = 0; c < this.chains.length; c++) {
        assets.rows[p+rowsBeforePlayers].cells[c+1].innerText = this.players[p].shares[c];
      }
      assets.rows[p+rowsBeforePlayers].cells[this.chains.length + 1].innerText = this.players[p].cash*100;
    }
    for (let c = 0; c < this.chains.length; c++) {
      assets.rows[1].cells[c+1].innerText = this.chains[c].size == 0 ? "-" : this.chains[c].size;
      assets.rows[2].cells[c+1].innerText = this.chains[c].size == 0 ? "-" : "$" + (this.getChainPrice(c) * 100);
      assets.rows[this.players.length + rowsBeforePlayers].cells[c+1].innerText = this.chains[c].sharesRemaining;
    }
  }

  playInitialTiles() {
    let earliestTile = null;
    let earliestTilePlayer = -1;
    for (let i = 0; i < this.players.length; i++) {
      let tile = this.drawTile();
      this.updateBoard(tile.i, tile.j, "single");
      if (earliestTile == null || tile.j < earliestTile.j ||
          (tile.j == earliestTile.j && tile.i < earliestTile.i)) {
        earliestTile = tile;
        earliestTilePlayer = i;
      }
    }

    this.currentPlayer = earliestTilePlayer;
  }

  async gameLoop() {
    while (true) {
      let tile = await this.selectTile(this.players[this.currentPlayer].tiles);
      await this.playTile(tile);
      this.updateAssets();
      await this.purchaseShares();

      let newTile = this.drawTile();
      if (newTile != undefined)
        this.players[this.currentPlayer].tiles.add(newTile);

      this.currentPlayer = (this.currentPlayer + 1) % this.players.length;
      this.updateAssets();
      if (this.gameOver()) {
        break;
      }
    }
  }

  updateBoard(i, j, value) {
    this.board[i][j] = value;
    let cell = document.getElementById("uiBoard").rows[i].cells[j];
    if (value == "open") {
      cell.innerText = "" + (i+1) + String.fromCharCode(65 + j);
      cell.style.backgroundColor = "white";
    } else if (value == "single") {
      cell.style.backgroundColor = "black";
      cell.innerText = "";
    } else {
      cell.style.backgroundColor = this.chains[value].color;
      cell.innerText = "";
      this.chains[value].size++;
    }
  }

  drawTile() {
    while (this.availableTiles.length > 0) {
      let i = Math.floor(Math.random() * this.availableTiles.length);
      let tile = this.availableTiles[i];
      this.availableTiles[i] = this.availableTiles[this.availableTiles.length - 1];
      this.availableTiles.pop();
      if (!this.isUnplayable(tile))
        return tile;
    }
  }

  isUnplayable(tile) {
    if (this.board[tile.i][tile.j] != "open")
      throw new Error("isUnplayable called on tile that was already played.");
    let neighboringSafeChain = null;
    for (let n of neighbors) {
      let ni = tile.i + n[0];
      let nj = tile.j + n[1];
      if (ni < 0 || nj < 0 || ni >= this.board.length || nj >= this.board[ni].length)
        continue;
      let nValue = this.board[ni][nj];
      if (nValue == "open" || nValue == "single")
        continue;
      if (this.chains[nValue].size < 11)
        continue;
      if (neighboringSafeChain == null)
        neighboringSafeChain = nValue;
      else if (neighboringSafeChain != nValue) {
        return true;
      }
    }
    return false;
  }

  isTemporarilyUnplayable(tile) {
    for (let c of this.chains) {
      if (c.size == 0)
        return false;
    }
    let hasNeighboringSingle = false;
    for (let n of neighbors) {
      let ni = tile.i + n[0];
      let nj = tile.j + n[1];
      if (ni < 0 || nj < 0 || ni >= this.board.length || nj >= this.board[ni].length)
        continue;
      let nValue = this.board[ni][nj];
      if (nValue == "open")
        continue;
      if (nValue == "single") {
        hasNeighboringSingle = true;
        continue;
      }
      // neighboring chain
      return false;
    }
    return hasNeighboringSingle;
  }

  async selectTile(tiles) {
    for (let t of tiles) {
      if (this.isUnplayable(t))
        tiles.delete(t);
    }
    while (tiles.size < 6) {
      let t = this.drawTile();
      if (t == undefined)
        break;
      tiles.add(t);
    }

    let tile;
    if (this.useAI(this.currentPlayer))
      tile = await this.selectTileAI(tiles);
    else
      tile = await this.selectTileUI(tiles);
    tiles.delete(tile);
    return tile;
  }

  async selectTileUI(tiles) {
    document.getElementById("prompt").innerText = "Select a tile to play";
    return new Promise(resolve => {
      for (let t of tiles) {
        let cell = uiBoard.rows[t.i].cells[t.j];
        if (this.isTemporarilyUnplayable(t)) {
          cell.style.border = "5px dashed gray";
          continue;
        }
        cell.style.border = "5px dashed black";
        cell.onclick = () => {
          for (let t of tiles) {
            uiBoard.rows[t.i].cells[t.j].onclick = null;
            uiBoard.rows[t.i].cells[t.j].style.border = "1px solid black";
          }
          document.getElementById("prompt").innerText = "";
          resolve(t);
        }
      }
    });
  }
  
  addNeighboringSingles(neighboringSingles, chain) {
    while(neighboringSingles.size > 0) {
      let n = neighboringSingles.keys().next().value;
      neighboringSingles.delete(n);
      this.updateBoard(n.i, n.j, chain);
      for (let nn of neighbors) {
        let nni = n.i + nn[0];
        let nnj = n.j + nn[1];
        if (nni < 0 || nnj < 0 || nni >= this.board.length || nnj >= this.board[nni].length)
          continue;
        if (this.board[nni][nnj] == "single")
          neighboringSingles.add({ i: nni, j: nnj });
      }
    }
  }

  async playTile(tile) {
    if (this.isUnplayable(tile))
      return Promise.reject("Tried to play unplayable tile");
    let neighboringChains = new Set();
    let neighboringSingles = new Set();
    for (let n of neighbors) {
      let ni = tile.i + n[0];
      let nj = tile.j + n[1];
      if (ni < 0 || nj < 0 || ni >= this.board.length || nj >= this.board[ni].length)
        continue;
      let nValue = this.board[ni][nj];
      if (nValue == "open")
        continue;
      if (nValue == "single") {
        neighboringSingles.add({ i: ni, j: nj });
        continue;
      }
      neighboringChains.add(nValue);
    }

    if (neighboringChains.size > 1) {
      // merge chains
      let survivingChain = await this.mergeChains(tile, neighboringChains);
      this.addNeighboringSingles(neighboringSingles, survivingChain);
    } else if (neighboringChains.size == 1) {
      // expand existing chain
      let neighboringChain = neighboringChains.keys().next().value;
      this.updateBoard(tile.i, tile.j, neighboringChain);
      this.addNeighboringSingles(neighboringSingles, neighboringChain);
    } else if (neighboringSingles.size >= 1) {
      // found new chain
      await this.foundChain(tile, neighboringSingles);
    } else {
      // new single
      this.updateBoard(tile.i, tile.j, "single");
    }
  }

  async foundChain(tile, neighboringSingles) {
    let chain = await this.selectChainToFound();
    this.updateBoard(tile.i, tile.j, chain);
    this.addNeighboringSingles(neighboringSingles, chain);

    if (this.chains[chain].sharesRemaining > 0) {
      this.chains[chain].sharesRemaining--;
      this.players[this.currentPlayer].shares[chain]++;
    } else {
      this.players[this.currentPlayer].cash += this.getChainPrice(chain);
    }
  }

  async selectNextChainToMerge(chainsToProcess) {
    let largestSize = 0;
    let largestSet = new Set();
    for (let c of chainsToProcess) {
      if (this.chains[c].size < largestSize)
        continue;
      if (this.chains[c].size > largestSize) {
        largestSize = this.chains[c].size;
        largestSet.clear();
      }
      largestSet.add(c);
    }
    if (largestSet.size == 1)
      return largestSet.keys().next().value;

    if (this.useAI(this.currentPlayer))
      return this.selectNextChainToMergeAI(largestSet);
    return this.selectChainUI(largestSet, "Select which chain to merge next", false);
  }
  
  payBonuses(c) {
    let price = this.getChainPrice(c);
    let playersWithShares = new Array();
    for (let i = 0; i < this.players.length; i++) {
      if (this.players[i].shares[c] > 0)
        playersWithShares.push(this.players[i]);
    }
    if (playersWithShares.length == 1) {
      // One player gets both bonuses
      playersWithShares[0].cash += (price * 15);
      return;
    }
    playersWithShares.sort((a,b) => {
      if (a.shares[c] < b.shares[c])
        return 1;
      if (a.shares[c] > b.shares[c])
        return -1;
      return 0;
    });
    if (playersWithShares[0].shares[c] == playersWithShares[1].shares[c]) {
      // tie for first
      let tiedPlayers = 2;
      for (; tiedPlayers < playersWithShares.length; tiedPlayers++) {
        if (playersWithShares[0].shares[c] != playersWithShares[tiedPlayers].shares[c])
          break;
      }
      let splitBonus = Math.ceil((price * 15) / tiedPlayers);
      for (let i = 0; i < tiedPlayers; i++) {
        playersWithShares[i].cash += splitBonus;
      }
      return;
    }
    
    // solo first place
    playersWithShares[0].cash += (price * 10);

    // split the second place bonus as necessary
    let secondPlaces = 1;
    for (; secondPlaces + 1 < playersWithShares.length; secondPlaces++) {
      if (playersWithShares[1].shares[c] != playersWithShares[1+secondPlaces].shares[c])
        break;
    }
    let splitBonus = Math.ceil((price * 5) / secondPlaces);
    for (let i = 0; i < secondPlaces; i++) {
      playersWithShares[1+i].cash += splitBonus;
    }
  }

  async mergeChains(tile, neighboringChains) {
    this.updateBoard(tile.i, tile.j, "single");
 
    let chain = await this.selectMergerChainToSurvive(neighboringChains);
    neighboringChains.delete(chain);

    let chainsToProcess = structuredClone(neighboringChains);
    while (chainsToProcess.size > 0) {
      let n = await this.selectNextChainToMerge(chainsToProcess);
      chainsToProcess.delete(n);
      this.payBonuses(n);
      this.updateAssets();
      await this.mergeShares(chain, n);
      this.chains[n].size = 0;
    }
    for (let i = 0; i < this.board.length; i++) {
      for (let j = 0; j < this.board[i].length; j++) {
        if (neighboringChains.has(this.board[i][j])) {
          this.updateBoard(i, j, chain);
        }
      }
    }
    this.updateBoard(tile.i, tile.j, chain);
    return chain;
  }

  async selectMergerChainToSurvive(neighboringChains) {
    let max = 0;
    let maxChains = new Set();
    for (let n of neighboringChains) {
      if (this.chains[n].size > max) {
        max = this.chains[n].size;
        maxChains.clear();
        maxChains.add(n);
      } else if (this.chains[n].size == max) {
        maxChains.add(n);
      }
    }
    if (maxChains.size == 1)
      return maxChains.keys().next().value;

    if (this.useAI(this.currentPlayer))
      return this.selectMergerChainToSurviveAI(maxChains);
    return this.selectChainUI(maxChains, "Select a chain to survive the merger", false);
  }

  async selectChainToFound() {
    let eligibleChains = new Set();
    for (let i = 0; i < this.chains.length; i++) {
      if (this.chains[i].size == 0)
        eligibleChains.add(i);
    }
    if (eligibleChains.size == 0)
      return Promise.reject("Tried to found a chain when all are active");
    if (this.useAI(this.currentPlayer))
      return this.selectChainToFoundAI(eligibleChains);
    return this.selectChainUI(eligibleChains, "Select a chain to found", false);
  }

  async selectChainUI(chains, promptText, showDoneOption) {
    document.getElementById("prompt").innerText = promptText;
    if (showDoneOption) {
      assets.rows[0].cells[0].innerText = "Done";
      chains.add(-1);
    }
    return new Promise(resolve => {
      for (let c of chains) {
        let cell = assets.rows[0].cells[c+1];
        cell.style.border = "5px dashed";
        cell.onclick = () => {
          for (let j = 0; j < assets.rows[0].cells.length; j++) {
            assets.rows[0].cells[j].onclick = null;
            assets.rows[0].cells[j].style.border = "1px solid";
          }
          document.getElementById("prompt").innerText = "";
          assets.rows[0].cells[0].innerText = "";
          resolve(c);
        }
      }
    });
  }

  async purchaseShares() {
    let player = this.players[this.currentPlayer];
    for (let i = 3; i > 0; i--) {
      let activeAndAffordableChains = new Set();
      for (let c = 0; c < this.chains.length; c++) {
        if (this.chains[c].size == 0 || this.chains[c].sharesRemaining == 0)
          continue;
        if (this.getChainPrice(c) > player.cash)
          continue;
        activeAndAffordableChains.add(c);
      }
      if (activeAndAffordableChains.size == 0)
        return;
      let c = await this.selectShareToPurchase(activeAndAffordableChains, i);
      if (c == -1) // Done
        return;
      player.cash -= this.getChainPrice(c);
      player.shares[c]++;
      this.chains[c].sharesRemaining--;
      this.updateAssets();
    }
  }

  async selectShareToPurchase(chains, iText) {
    if (this.useAI(this.currentPlayer))
      return this.selectShareToPurchaseAI(chains);
    return this.selectChainUI(chains, "Purchase up to " + iText + " shares", true);
  }
  
  async mergeShares(survivingChain, mergingChain) {
    for (let i = 0; i < this.players.length; i++) {
      let p = (this.currentPlayer + i) % this.players.length;
      assets.rows[rowsBeforePlayers + p].cells[1 + mergingChain].style.border = "5px black solid";
      while (this.players[p].shares[mergingChain] > 0) {
        let options = new Set();
        options.add(7); // cash
        if (this.players[p].shares[mergingChain] > 1 && this.chains[survivingChain].sharesRemaining > 0)
          options.add(survivingChain);
        let choice = await this.selectMergeOption(options, p);
        if (choice == -1)
          break;
        if (choice == 7) {
          this.players[p].shares[mergingChain]--;
          this.chains[mergingChain].sharesRemaining++;
          this.players[p].cash += this.getChainPrice(mergingChain);
        } else {
          // 2-for-1 swap
          this.players[p].shares[mergingChain] -= 2;
          this.chains[mergingChain].sharesRemaining += 2;
          this.players[p].shares[survivingChain]++;
          this.chains[survivingChain].sharesRemaining--;
        }
        this.updateAssets();
      }
      assets.rows[rowsBeforePlayers + p].cells[1 + mergingChain].style.border = "1px black solid";
    }
  }

  async selectMergeOption(options, player) {
    if (this.useAI(player))
      return this.selectMergeOptionAI(options);
    return this.selectChainUI(options, "Sell, trade, or hold your shares", true);
  }

  isGameOver() {
    let hasSafeChain = false;
    let hasUnsafeChain = false;
    for (let c of this.chains) {
      let size = c.size;
      if (size >= 41)
        return true;
      if (size >= 11)
        hasSafeChain = true;
      else if (size > 0)
        hasUnsafeChain = true;
    }
    return hasSafeChain && !hasUnsafeChain;
  }

  gameOver() {
    if (!this.isGameOver())
      return false;
    this.currentPlayer = null;
    for (let c = 0; c < this.chains.length; c++) {
      if (this.chains[c].size == 0)
        continue;
      this.payBonuses(c);
      let price = this.getChainPrice(c);
      for (let p of this.players) {
        p.cash += (p.shares[c] * price);
        this.chains[c].sharesRemaining += p.shares[c];
        p.shares[c] = 0;
      }
    }
    let winningCash = 0;
    for (let p of this.players) {
      winningCash = Math.max(winningCash, p.cash);
    }
    this.updateAssets();

    for (let i = 0; i < this.players.length; i++) {
      if (this.players[i].cash == winningCash)
        assets.rows[rowsBeforePlayers + i].cells[0].style.border = "5px green solid";
    }
    document.getElementById("prompt").innerText = "Game over!";
    return true;
  }

  selectTileAI(tiles) {
    let i = Math.floor(Math.random() * tiles.size);
    let tile = Array.from(tiles)[i];
    if (this.isTemporarilyUnplayable(tile))
      return this.selectTileAI(tiles);
    return Array.from(tiles)[i];
  }

  selectNextChainToMergeAI(chains) {
    let i = Math.floor(Math.random() * chains.size);
    return Array.from(chains)[i];
  }

  selectMergerChainToSurviveAI(chains) {
    let i = Math.floor(Math.random() * chains.size);
    return Array.from(chains)[i];
  }

  selectChainToFoundAI(chains) {
    let i = Math.floor(Math.random() * chains.size);
    return Array.from(chains)[i];
  }

  selectShareToPurchaseAI(chains) {
    let i = Math.floor(Math.random() * chains.size);
    return Array.from(chains)[i];
  }

  selectMergeOptionAI(options) {
    let i = Math.floor(Math.random() * options.size);
    return Array.from(options)[i];
  }
}
</script>